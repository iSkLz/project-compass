import { promises as fs } from "fs";
import { task, utils } from "@libs/helpers"

const timeFormatter = new Intl.DateTimeFormat("en-us", {
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short"
});

function defaultFormatter(message: string, level: LogLevels, tag?: string) {
    let msg = timeFormatter.format(new Date());
    if (tag) msg += ` [${tag}]`;
    msg += ` [${levelTags[level]}] ${message}`;
    return msg;
}

export const levelTags = ["Debug", "Dev", "Info", "Warning", "Problem", "Error", "Abort"];

export const enum LogLevels {
    /**
     * Verbose messages. Use to log random stuff in development.
     */
    Debug,

    /**
     * Messages for developers only. Use to log data only meaningful for developers.
     */
    Dev,

    /**
     * General messages. Use to log activities and events.
     */
    Info,

    /**
     * Warnng messages. Use to log potential problems and problematic states.
     */
    Warning,

    /**
     * Sub-error warning messages. Use to log problems that didn't cause errors but could've done so.
     */
    Problem,

    /**
     * Error messages. Use to log errors that can be recovered from.
     */
    Error,

    /**
     * Crash messages. Use to log errors that interrupt the code flow.
     */
    Abort,
}

export type LoggerWriter = (out: string) => Promise<void>;
export type LoggerTerminator = () => Promise<void>;

export class LoggerOutput {
    public writer: LoggerWriter;
    public terminator: LoggerTerminator;
    
    /**
     * Creates a logger that outputs to a file.
     */
    public static async fromFile(path: string) {
        if (typeof path === "string") {
            let file = await fs.open(path, "w");
            return new LoggerOutput(async (msg) => {
                await file.write(Buffer.from(msg + "\n"));
            }, async () => {
                file.close();
            });
        }
    }

    /**
     * Create a logger that outputs to the terminal.
     * Only works on the main process, use webConsole for renderer processes.
     */
    public static nodeConsole() {
        if ((globalThis as any).window != undefined && (globalThis as any).window.document != undefined)
            throw new Error("This method isn't operation on a renderer process.");
        
        if (!process.stdout.isTTY)
            throw new Error("The stdout stream doesn't output to a terminal.");

        return new LoggerOutput((msg) => {
            return new Promise((resolve, reject) => {
                if (!process.stdout.write(msg + "\n", (err) => {
                    if (err) reject(err);
                    else resolve();
                })) {
                    process.stdout.once("drain", resolve);
                }
            });
        });
    }

    /**
     * Creates an output that logs to the console directly.
     * Use only on renderer processes, and use nodeConsole on the main process.
     */
    public static webConsole() {
        return new LoggerOutput(async (msg) => console.log(msg));
    }

    constructor(output: LoggerWriter, terminator: LoggerTerminator = async () => {}) {
        this.writer = output;
        this.terminator = terminator;
    }
}

// TODO: Custom formatting
export type LoggerFormatter = (message: string, level: LogLevels, tag?: string) => string;

/**
 * Implements asynchronous logging with support for multiple outputs.
 * Use this over console.log, as that completely blocks the main process on some systems.
 * See: https://devdocs.io/node/process#process_a_note_on_process_i_o
 */
export class Logger {
    public minLevel: LogLevels;
    public formatter: LoggerFormatter;
    
    private terminated: boolean = false;
    private output: LoggerOutput[];
    private queue = new task.TaskQueue();

    //#region Properties
    public get isTerminated() {
        return this.terminated;
    }

    /**
     * The outputs of the logger.
     * Do not push to this manually, use addOutputs instead.
     */
    public get outputs() {
        return this.output;
    }

    /**
     * Whether the logger is currently logging or not.
     */
    public get isLogging() {
        return this.queue.isActive;
    }

    /**
     * A promise that resolves when all logging has finished.
     * Note: The promise won't resolve until the logger hits an inactivity state.
     * Use this promise with caution, if the logger is actively used it may never resolve.
     */
    public get onFullFinish() {
        return this.queue.onFullFinish;
    }

    /**
     * A promise that resolves when the logging that is ongoing at the time this promise was
     * retrieved finishes.
     */
    public get onFinish() {
        return this.queue.onFinish
    }
    //#endregion

    constructor(outputs: LoggerOutput[], formatter: LoggerFormatter = defaultFormatter, minLevel?: LogLevels) {
        if (minLevel) this.minLevel = minLevel;
        else this.minLevel = LogLevels.Info; // TODO: Check core config for dev

        this.output = outputs;
        this.formatter = formatter;
    }

    /**
     * Terminate the logger and all outputs after all ongoing logging is finished.
     * Further logging requests won't do anything.
     * Do call this when you don't need a logger anymore to free up resources.
     * This will release the held reference to logger outputs, so if you don't have them
     * referenced they will get garbage collected.
     */
    public async terminate(): Promise<void> {
        this.terminated = true;
        await this.onFinish;

        // The length is evaluated every iteration
        // We need the full starting length and not the current length of every iteration
        let len = this.output.length;
        for (let i = 0; i < len; i++) {
            await (this.output.pop() as LoggerOutput).terminator();
        }
    }

    /**
     * Adds one or more logging output(s) to the logger after all ongoing logging has finished.
     */
    public async addOutputs(...outputs: LoggerOutput[]): Promise<void> {
        this.queue.push(async () => {
            this.output.push(...outputs);
        });
    }

    /**
     * Asynchronously logs a message to the specified outputs.
     * You can safely log again before the returned promise resolves.
     * @param message The message to log
     * @param level The level of the message
     * @param tag The prepended tag of the message
     */
    public log(message: string, level: LogLevels = LogLevels.Info, tag?: string): Promise<void> {
        if (this.terminated || level < this.minLevel) return utils.immediatePromise();
        
        if (level == undefined) level = LogLevels.Info;
        let msg: string | undefined = undefined;

        let tasks: task.TaskFunction<void>[] = [];
        for (let i = 0; i < this.output.length; i++) {
            tasks.push(async () => {
                await this.output[i].writer((msg as string));
            });
        }
        const batch = task.taskBatch(tasks);
        return this.queue.push(async () => {
            msg = this.formatter(message, level, tag);
            await batch();
        });
    }
}