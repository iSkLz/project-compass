import { promises as fs } from "fs";

const timeFormatter = new Intl.DateTimeFormat("en-us", {
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short"
});

export const levelTags = ["Debug", "Dev", "Info", "Warning", "Problem", "Error", "Abort"];

export const enum LogLevels {
    /**
     * Verbose messages. Use to log random stuff in development.
     */
    Debug,

    /**
     * Messages for developers only. Use to log data only meaningful for developers.
     */
    Dev,

    /**
     * General messages. Use to log activities and events.
     */
    Info,

    /**
     * Warnng messages. Use to log potential problems and problematic states.
     */
    Warning,

    /**
     * Sub-error warning messages. Use to log problems that didn't cause errors but could've done so.
     */
    Problem,

    /**
     * Error messages. Use to log errors that can be recovered from.
     */
    Error,

    /**
     * Crash messages. Use to log errors that interrupt the code flow.
     */
    Abort,
}

export type LoggerWriter = (out: string) => Promise<void>;
export type LoggerTerminator = () => Promise<void>;

export class LoggerOutput {
    public writer: LoggerWriter;
    public terminator: LoggerTerminator;
    
    /**
     * Creates a logger that outputs to a file.
     */
    public static async fromFile(path: string) {
        if (typeof path === "string") {
            let file = await fs.open(path, "w");
            return new LoggerOutput(async (msg) => {
                await file.write(Buffer.from(msg));
            }, async () => {
                file.close();
            });
        }
    }

    /**
     * Create a logger that outputs to the terminal. Only works on the main process.
     */
    public static async nodeConsole() {
        if (!!globalThis.window && !!globalThis.window.document)
            throw new Error("This method isn't operation on a renderer process.");
        
        if (!process.stdout.isTTY)
            throw new Error("The stdout stream doesn't output to a terminal.");

        return new LoggerOutput((msg) => {
            return new Promise((resolve, reject) => {
                if (!process.stdout.write(msg, (err) => {
                    if (err) reject(err);
                    else resolve();
                })) {
                    process.stdout.once("drain", resolve);
                }
            });
        });
    }

    public static async webConsole() {
        return new LoggerOutput(async (msg) => console.log(msg));
    }

    constructor(output: LoggerWriter, terminator: LoggerTerminator = async () => {}) {
        this.writer = output;
        this.terminator = terminator;
    }
}

// TODO: Custom formatting
export type LoggerFormatter = () => string;

/**
 * Implements asynchronous logging with support for multiple outputs.
 * Use this over console.log, as that completely blocks the main process on some systems.
 * See: https://devdocs.io/node/process#process_a_note_on_process_i_o
 */
export default class Logger {
    public minLevel: LogLevels;
    
    private terminated: boolean = false;
    private output: LoggerOutput[];
    private ongoing: Promise<void> | undefined;

    //#region Properties
    public get isTerminated() {
        return this.terminated;
    }

    /**
     * The outputs of the logger.
     * Do not push to this manually, use addOutputs instead.
     */
    public get outputs() {
        return this.output;
    }

    /**
     * Whether the logger is currently logging or not.
     */
    public get isLogging() {
        return !!this.ongoing;
    }

    /**
     * A promise that resolves when all logging has finished.
     * Note: The promise won't resolve until the logger hits an inactivity state.
     * Use this promise with caution, if the logger is actively used it may never resolve.
     */
    public get onFullFinish() {
        return new Promise((resolve) => {
            if (!this.isLogging) resolve();
            let ongoing: Promise<void> | undefined = undefined;
            let check = () => {
                if (ongoing !== this.ongoing) {
                    ongoing = this.ongoing;
                    this.ongoing.then(check);
                } else {
                    resolve();
                }
            };
            check();
        });
    }

    /**
     * A promise that resolves when the logging that is ongoing at the time this promise was
     * retrieved finishes.
     */
    public get onFinish() {
        return new Promise((resolve) => {
            if (!this.isLogging) resolve();
            this.ongoing.then(resolve);
        });
    }
    //#endregion

    constructor(outputs: LoggerOutput[], minLevel?: LogLevels) {
        if (minLevel) this.minLevel = minLevel;
        else this.minLevel = LogLevels.Info; // TODO: Check core config for dev

        this.output = outputs;
    }

    /**
     * Terminate the logger and all outputs after all ongoing logging is finished.
     * Further logging requests won't do anything.
     * Do call this when you don't need a logger anymore to free up resources.
     * This will release the held reference to logger outputs, so if you don't have them
     * referenced they will get garbage collected.
     */
    public async terminate(): Promise<void> {
        this.terminated = true;
        await this.onFinish;

        // The length is evaluated every iteration
        // We need the full starting length and not the current length of every iteration
        let len = this.output.length;
        for (let i = 0; i < len; i++) {
            await this.output.pop().terminator();
        }
    }

    /**
     * Adds one or more logging output(s) to the logger after all ongoing logging has finished.
     * See onFullFinish for more info.
     */
    public async addOutputs(...outputs: LoggerOutput[]): Promise<void> {
        await this.onFullFinish;
        this.output.push(...outputs);
    }

    /**
     * Asynchronously logs a message to the specified outputs.
     * You can safely log again before the returned promise resolves.
     * @param message The message to log
     * @param level The level of the message
     * @param tag The prepended tag of the message
     */
    public log(message: string, level: LogLevels = LogLevels.Info, tag?: string): Promise<void> {
        if (this.terminated || level < this.minLevel) return;

        let ongoing = this.ongoing;

        // Replace the promise so that successive calls create a logging train of promises
        var self = (this.ongoing = new Promise<void>((resolve) => {
            let msg = timeFormatter.format(new Date());
            if (tag) msg += ` [${tag}]`;
            msg += ` [${levelTags[level]}] ${message}`;
    
            if (ongoing != undefined)
            {
                ongoing.then(() => {
                    this._log(msg);
                }).then(resolve);
            } else {
                this._log(msg).then(resolve);
            }
        }));

        return self.then(() => {
            // If when logging is done, no new logging has been requested, set to undefined
            if (this.ongoing === self) this.ongoing = undefined;
        });
    }

    private async _log(msg: string) {
        for (let i = 0; i < this.output.length; i++) {
            await this.output[i].writer(msg);
        }
    }
}