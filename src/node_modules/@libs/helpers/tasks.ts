export type TaskFunction<T> = () => Promise<T>;

/**
 * Creates a batch of tasks that will be executed in parallel.
 * Can be used with the TaskQueue class or used alone.
 * @param tasks List of tasks to execute
 * @returns A task that "finishes" when all tasks have finished.
 */
export function taskBatch(tasks: TaskFunction<unknown>[]): TaskFunction<void> {
    return () => {
        return new Promise(resolve => {
            let count = tasks.length;

            function update() {
                if (--count == 0) resolve();
            }

            for (const task of tasks) {
                task().then(update);
            }
        });
    }
}

/**
 * Represents a queue of asynchronous tasks that is ensured to run one by one in the correct order (FIFO).
 */
export class TaskQueue {
    /**
     * The current running task, if one exists, or undefined.
     */
    public current: Promise<any> | undefined;

    /**
     * The queue of current tasks, if any exist, or undefined.
     */
    public queue: Promise<any> | undefined;

    /**
     * Returns the current count of running tasks.
     */
    public get count() {
        return this._count;
    }
    private _count: number = 0;

    /**
     * Whether any tasks are in execution or not
     */
    public get isActive() {
        return this.queue != undefined;
    }
    
    /**
    * A promise that resolves when the queue is fully drained.
    * Note: The promise won't resolve until the queue hits an inactivity state.
    * Use this promise with caution, if the queue is actively pushed to it may never resolve.
    */
    public get onFullFinish() {
        return (async () => {
            if (!this.isActive) return;

            let current: Promise<void> | undefined = undefined;
            while (current !== this.queue) {
                current = this.queue;
                await this.queue;
            }
        })();
    }

    /**
     * A promise that resolves when all the tasks queued finish.
     * This may never resolve if new tasks are frequently pushed.
     */
    public get onFinish() {
        return (async () => {
            if (!this.isActive) return;
            await this.queue;
        })();
    }

    /**
     * A promise that resolves when the task running at the invoking time finishes.
     */
    public get onCurrentFinish() {
        return (async () => {
            if (this.current == undefined) return;
            await this.current;
        })();
    }

    /**
     * Schedules a task to be executed at the end of the current queue
     * @param task An asynchronous function executing a task
     */
    public push<T>(task: TaskFunction<T>): Promise<T> {
        this._count++;
        
        let queue = this.queue;
        let wrapper = (async () => {
            if (queue != undefined) await queue;
            let promise = this.current = task();
            let res = await promise;
            this.current = undefined;
            this._count--;
            return res;
        })();
        this.queue = wrapper;

        return new Promise<T>((resolve) => {
            wrapper.then((val) => {
                if (this.queue === wrapper) this.queue = undefined;
                resolve(val);
            });
        });
    }
}