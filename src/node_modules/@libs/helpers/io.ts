import fs, { promises as pfs } from "fs";
import path from "path";
import { assignDefaults } from "./utils.js";

//#region Types & Enums
export interface ScanOptions {
    /**
     * Whether the returned paths should be relative to the root directory
     */
    relativeMode: boolean;

    /**
     * What to scan for
     */
    mode: ScanMode;

    /**
     * An optional callback to call on each file found
     */
    callback: FileCallback;

    /**
     * An optional callback to call on each folder found
     */
    dirCallback: DirCallback;
}

export const defaultScanOptions: ScanOptions = {
    relativeMode: false,
    mode: ScanMode.all,
    callback: async () => true,
    dirCallback: async () => ScanMode.auto,
}

/**
 * A binary flags enum for scan modes
 */
export const enum ScanMode {
    /**
     * Don't scan for anything
     */
    none = 0,

    /**
     * Scan for files
     */
    files = 1 << 0,

    /**
     * Scan for directories
     */
    dirs = 1 << 1,

    /**
     * Don't scan inner directories
     */
    outer = 1 << 2,

    /**
     * Let the function decide
     */
    auto = 1 << 3,

    /**
     * Scan for both files and directories
     */
    all = files | dirs,

    /**
     * Scan for files and don't scan inner directories
     */
    outerOnlyFiles = files | outer,

    /**
     * Scan for directories and don't scan inner directories
     */
    outerOnlyDirs = dirs | outer,

    /**
     * Scan for both directories and files and don't scan inner directories
     */
    outerAll = all | outer,
}

export type ScanResults = {
    files: string[],
    dirs: string[];
}

export type FileCallback = 
/**
 * @param file The relative path of the file
 * @param dir The relative path of the parent directory
 * @returns Whether the file should be included in the returned files list
 */
(file: string, dir: string) => Promise<boolean>;

export type DirCallback =
/**
 * @param dir The relative path of the directory
 * @returns How the directory should be scanned
 */
(dir: string) => Promise<ScanMode | boolean>;
//#endregion
/**
 * Recursively scans a directory tree collecting a list of existing files.
 * Use the directory callback to decide the scan mode for nested directories.
 * The scan will overflow the call stack (error) on the 15568th directory nesting level.
 * @param root The root of the scan
 * @param dir The starting directory of the scan
 * @returns A list of file/directory paths within the directory tree
 */
 export async function recurseScan(
    root: string,
    scanOptions: Partial<ScanOptions> = defaultScanOptions,
    dir: string = "."
): Promise<ScanResults> {
    // TODO: Use a task batch for sub directories (if that's a viable option)
    let options = assignDefaults(scanOptions, defaultScanOptions);

    if (options.mode === ScanMode.none) return {files: [], dirs: []};
    if (options.mode === ScanMode.auto) options.mode = ScanMode.all;

    root = path.resolve(root);
    let files: string[] = [];
    let dirs: string[] = [];
    
    const entries = await pfs.readdir(path.join(root, dir), {
        // Use fs.Dirents
        withFileTypes: true
    });

    async function innerScan(innerDir: string, mode: ScanMode) {
        const res = await recurseScan(root, {
            relativeMode: true,
            callback: options.callback,
            dirCallback: options.dirCallback,
            mode,
        }, innerDir);

        files = files.concat(res.files);
        dirs = dirs.concat(res.dirs);
    }

    for (const dirent of entries) {
        const fullPath = path.join(dir, dirent.name);

        if (dirent.isDirectory()) {
            // If the scan includes directories, push it
            if (options.mode & ScanMode.dirs) dirs.push(fullPath);
            
            // If the scan includes inner directories, scan it
            if (!(options.mode & ScanMode.outer)) {
                let mode = await options.dirCallback(fullPath);
                if (mode == ScanMode.auto || mode === true) mode = options.mode;
                if (typeof mode !== "boolean")
                    await innerScan(fullPath, mode);
            }
        } else {
            // If the scan includes files, push it
            let callbackRes = await options.callback(dirent.name, dir);
            if ((options.mode & ScanMode.files) && callbackRes) files.push(fullPath);
        }
    };

    if (!options.relativeMode) {
        files = files.map(entry => path.join(root, entry));
        dirs = dirs.map(entry => path.join(root, entry));
    }

    return {
        files, dirs
    }
}

/**
 * Parses the JSON file at the specified path and returns the result
 * @param filePath Path to a JSON file
 */
export async function parseJSON<T>(filePath: string): Promise<T> {
    return JSON.parse(await pfs.readFile(filePath, "utf8"));
}

/**
 * Synchronously parses the JSON file at the specified path and returns the result.
 * Note: Avoid using the synchronous version as much as possible
 * @param filePath Path to a JSON file
 */
export function parseJSONSync(filePath: string) {
    return JSON.parse(fs.readFileSync(filePath, "utf8"));
}