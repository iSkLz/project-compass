import { promises as fs } from "fs";
import path from "path";
import { ipcMain } from "electron";
import { utils, io } from "@libs/helpers";
import { isPlainObject } from "jquery";

// A map of languages by ID
// Each language is a map of locals by paths
// Each local is a map of strings by keys
export var locals: Map<string, Map<string, Map<string, string>>> = new Map<string, Map<string, Map<string, string>>>();
export var activeLanguageID = "en-us";

export function activeLanguage() {
    return getLanguage(activeLanguageID);
}

/**
 * Retrieves a language dictionary by its ID
 */
export function getLanguage(ID: string) {
    ID = ID.toLowerCase();
    let local = locals.get(ID);

    if (local == undefined) {
        local = new Map<string, Map<string, string>>();
        locals.set(ID, local);
    }

    return local;
}

/**
 * Loads locals from a locals directory.
 * @param scanDir The directory to scan.
 * @param localsRoot The default root of locals path.
 * Must be provided or else unexpected behavior will occur when a local file doesn't contain a path.
 */
export async function scan(scanDir: string, localsRoot: string) {
    const res = await io.recurseScan(scanDir, {
        mode: io.ScanMode.outerOnlyDirs
    });

    for (let dir of res.dirs) {
        // Scan for all inner .json files
        dir = path.join(scanDir, dir);
        // Directory's name is the language ID
        const langID = path.parse(dir).name;

        const res = await io.recurseScan(dir, {
            relativeMode: true,
            callback: async (file) => file.endsWith(".json")
        });

        for (const localPath of res.files) {
            const fullPath = path.join(scanDir, dir, localPath);
            // Relative to the root directiory, extensionless, POSIX-like
            const defaultPath = (localsRoot + "/" + localPath.substring(0, localPath.length - 5)).replace(/\\/, "/");

            load(langID, fullPath, defaultPath);
        }
    }
}

/**
 * Loads locals from a file
 * @param lang The language of the file
 * @param filePath Path to the locals file
 * @param localPath Path of the locals
 */
export async function load(lang: string, filePath: string, localPath: string) {
    const content = await io.parseJSON<any>(filePath);
    
    // Default to the automatic path if a path isn't set in the file
    if (!content._path) content.path = localPath;
    else content.path = content._path;
    const langDict = getLanguage(lang);

    let dict = langDict.get(content.path);
    if (dict == undefined) {
        dict = new Map<string, string>();
        langDict.set(content.path, dict);
    }


    // Object -> map
    delete content.path;
    if (!!content._path) delete content._path;
    for (const key in content) {
        dict.set(key, content[key]);
    }

    // Recursive function to replace embedded local references
    let fixLocal = (key: string): string => {
        const value = dict?.get(key) || "";

        const newvalue = value.replace(/\{(\w+)\}/g, (_match, subkey) => {
            return fixLocal(subkey);
        });

        dict?.set(key, newvalue);
        return newvalue;
    };
    
    // Already fixed locals will be skipped since the regex in the function won't find anything
    for (const kvp of dict) {
        fixLocal(kvp[0]);
    }
}

//#region IPC Handlers
function handleIPC(event: any, arg: any): string {
    let request = JSON.parse(arg);

    const path = request.path;
    switch (request.type) {
        case "path":
            const content = activeLanguage()?.get(path);
            if (content != undefined)
                return JSON.stringify(utils.mapToObject(content));
        case "key":
            const key = request.key;
            const local = activeLanguage()?.get(path)?.get(key);
            if (local != undefined)
                return local;
    }
    
    return JSON.stringify({});
}

ipcMain.on("local", (event, arg) => {
    event.returnValue = handleIPC(event, arg);
});

ipcMain.handle("local", async (event, arg) => {
    return handleIPC(event, arg);
});
//#endregion