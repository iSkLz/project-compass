import { promises as fs, existsSync } from "fs";
import path from "path";

import { utils, paths, io, task } from "@libs/helpers";

// Note: It's okay to use platform-specific path separators here since both getter and setter paths are normalized

export default class Config {
    // A static member to keep track of all current Config instances
    public static Instances: WeakSet<Config> = new WeakSet<Config>();

    public root: string;

    private config: Map<string, any>;

    constructor(folder: string) {
        // Register the newly cosntructed Config instance
        Config.Instances.add(this);

        this.root = path.join(paths.save, path.normalize(folder));
        this.config = new Map<string, any>();
    }

    public async init() {
        // Mkdir -P
        if (!existsSync(this.root)) await fs.mkdir(this.root, {
            recursive: true
        });

        const res = await io.recurseScan(this.root, {});

        for (const filePath of res.files) {
            // Get the path relative to the specified root
            const storePath = path.relative(this.root, filePath);
            
            // Read the file as JSON, and store it
            let content: any;
            
            try {
                content = io.parseJSON(filePath);
            } catch {
                // TODO: Maybe we can detect & attempt to fix invalid JSON?
                content = {};
            }

            this.config.set(storePath, content);
        }
    }

    /**
     * Saves the current Config to the filesystem.
     * Compass automatically calls this when needed
     */
    public async save() {
        // Iterate every file, serialize its content to JSON and save it to its respective path
        let tasks: task.TaskFunction<void>[] = [];
        for (const keyValue of this.config) {
            const [key, value] = keyValue;
            tasks.push(async () => {
                await fs.writeFile(path.join(this.root, key), JSON.stringify(value));
            });
        }

        await task.taskBatch(tasks);
    }

    /**
     * Gets the value of a path
     * @param pathName The path of the value to get
     * @param defaultValue The value to use in case the path doesn't exist yet
     * @returns The value of the requested path
     */
    public get<T>(pathName: string, defaultValue: T): T {
        pathName = path.normalize(pathName);

        let value: T;
        // Use the default value if the path doesn't exist yet
        if (!this.config.has(pathName)) this.config.set(pathName, value = defaultValue);
        else value = this.config.get(pathName);

        return value;
    }

    /**
     * Merges an object into an existing one
     * @param pathName The path of the object to merge
     * @param merged The object to merge
     * @param override Whether to override existing properties
     * @returns The new merged object
     */
    public merge(pathName: string, merged: any, override: boolean = true): any {
        pathName = path.normalize(pathName);

        // Get the target object
        let obj = this.get<any>(pathName, {});

        // If overriding properties is allowed, use Object.assign
        if (override) return Object.assign(obj, merged);

        // Otherwise manually copy the properties one by one
        const keys = Object.keys(merged);
        for (const key of keys) {
            // Do not override existing properties
            if (obj.hasOwnProperty(key)) continue;

            obj[key] = merged[key];
        }

        return obj;
    }

    /**
     * Sets the value of a path
     * @param pathName Path of the value to set
     * @param value The value to set
     * @returns The set value
     */
    public set<T>(pathName: string, value: T): T {
        this.config.set(path.normalize(pathName), value);
        return value;
    }
}